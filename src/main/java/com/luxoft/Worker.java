package com.luxoft;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.*;
import java.util.stream.IntStream;

/**
 * You need to write to a file the sequence of 100,000,000 bytes generated by java Random class with seed = 0.
 * In the fastest way possible.
 */
public class Worker {
    private static int N_THREADS = Runtime.getRuntime().availableProcessors();
    private static String DEFAULT_CATALOG = "results";
    private static int BATCH_SIZE = 512*8;

    private Random random;
    private int fileSize;
    private String catalog;
    public Worker(long seed, int fileSize, String catalog) {
        random = new Random(seed);
        if (catalog == null || "".equals(catalog.trim()))
            catalog = DEFAULT_CATALOG;
        File dir = new File(catalog);
        dir.mkdir();
        this.catalog = catalog + "/";
        this.fileSize = fileSize;
    }

    // Generating
    public byte[] generateBytesLibParallel() { // if you repeat this method it will give you another result
        long tStart = System.currentTimeMillis();
        String opName = "generateBytesLibParallel";
        byte[] bytes = new byte[fileSize];
        List<BatchIndex> batches = getBatchesByNumThreads();
        ExecutorService generatorExecutor = Executors.newFixedThreadPool(N_THREADS);

        List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> CompletableFuture.runAsync(() -> {
                    int start = batch.getStart();
                    int length = batch.getEnd() - batch.getStart();

                    nextBytesLibBatch(bytes, start, length);
                }, generatorExecutor))
                .toList();
        futures.forEach(CompletableFuture::join);
        generatorExecutor.shutdown();
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return bytes;
    }
    public byte[] generateBytesLib() {
        long tStart = System.currentTimeMillis();
        byte[] bytes = new byte[fileSize];
        random.nextBytes(bytes);
        long tEnd = System.currentTimeMillis();
        logTime("generateBytesLib", tStart, tEnd);
        return bytes;
    }
    public byte[] generateBytes() { // not optimal
        long tStart = System.currentTimeMillis();
        byte[] bytes = new byte[fileSize];
        for (int i = 0; i < fileSize; i++) {
            bytes[i] = generateByte();
        }
        long tEnd = System.currentTimeMillis();
        logTime("generateBytes", tStart, tEnd);
        return bytes;
    }
    public byte[] generateBytesParallel() { // not optimal
        long tStart = System.currentTimeMillis();
        ExecutorService generatorExecutor = Executors.newFixedThreadPool(N_THREADS);

        byte[] bytes = new byte[fileSize];
        List<BatchIndex> batches = getBatchesByNumThreads();
        List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> CompletableFuture.runAsync(() -> {
                    System.out.println("started thread = " + Thread.currentThread().getName());
                    for (int i = batch.getStart(); i < batch.getEnd(); i++) {
                        bytes[i] = generateByte();
                    }
                }, generatorExecutor)).toList();
        futures.forEach(CompletableFuture::join);
        long tEnd = System.currentTimeMillis();
        logTime("generateBytesParallel", tStart, tEnd);
        generatorExecutor.shutdown();
        return bytes;
    }
    public byte[] generateBytesParallel2() {
        long tStart = System.currentTimeMillis();
        byte[] bytes = new byte[fileSize];
        ExecutorService generatorExecutor = Executors.newFixedThreadPool(N_THREADS);

        List<BatchIndex> batches = getBatchesByNumThreads();
        List<CompletableFuture<byte[]>> futures = batches.stream()
                .map(batch -> CompletableFuture.supplyAsync(() -> {
                    //System.out.println("started thread = " + Thread.currentThread().getName());
                    int size = batch.getEnd() - batch.getStart();
                    byte[] batchResult = new byte[size];
                    random.nextBytes(batchResult);
                    return batchResult;
                }, generatorExecutor)).toList();
        futures.forEach(CompletableFuture::join);
        int counter = 0;
        for (CompletableFuture<byte[]> future : futures) {
            try {
                byte[] byteResult = future.get();
                for (byte b : byteResult) {
                    bytes[counter++] = b;
                }
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }
        long tEnd = System.currentTimeMillis();
        logTime("generateBytesParallel", tStart, tEnd);
        generatorExecutor.shutdown();
        return bytes;
    }
    public byte[] generateBytesParallel3() {
        long tStart = System.currentTimeMillis();
        byte[] bytes = new byte[fileSize];
        ExecutorService generatorExecutor = Executors.newFixedThreadPool(N_THREADS);

        List<BatchIndex> batches = getBatchesByNumThreads();
        List<Future<byte[]>> futures = new ArrayList<>();
        for (BatchIndex batch : batches) {
            Future<byte[]> future = generatorExecutor.submit(() -> {
                //System.out.println("started thread = " + Thread.currentThread().getName());
                int size = batch.getEnd() - batch.getStart();
                byte[] batchResult = new byte[size];
                random.nextBytes(batchResult);
                return batchResult;
            });
            futures.add(future);
        }
        int counter = 0;
        for (Future<byte[]> future : futures) {
            try {
                byte[] byteResult = future.get();
                for (byte b : byteResult) {
                    bytes[counter++] = b;
                }
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }
        long tEnd = System.currentTimeMillis();
        logTime("generateBytesParallel", tStart, tEnd);
        generatorExecutor.shutdown();
        return bytes;
    }
    public Byte[] generateBytesStreamParallel() {
        long tStart = System.currentTimeMillis();
        Byte[] bytes = IntStream.range(0, fileSize).boxed()
                .map(number -> generateByte())
                .toArray(Byte[]::new);
        long tEnd = System.currentTimeMillis();
        logTime("generateBytesStreamParallel", tStart, tEnd);
        return bytes;
    }

    // Writing
    public String writeRandomAccessFileParallel(byte[] bytes) {
        long tStart = System.currentTimeMillis();
        String opName = "writeRandomAccessFileParallel";
        String fileName = getFileName(opName);
        ExecutorService writerExecutor = Executors.newFixedThreadPool(N_THREADS);

        List<BatchIndex> batches = getBatchesByNumThreads();
        List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> CompletableFuture.runAsync(() -> {
                    try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
                        try {
                            int start = batch.getStart();
                            int length = batch.getEnd() - batch.getStart();
                            raf.seek(start);
                            raf.write(bytes, start, length);
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    } catch (IOException ex) {
                        System.out.println(ex.getMessage());
                    }
                }, writerExecutor))
                .toList();
        futures.forEach(CompletableFuture::join);
        writerExecutor.shutdown();
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }
    public String writeFileOutputStream(byte[] bytes) {
        long tStart = System.currentTimeMillis();
        String opName = "writeFileOutputStream";
        String fileName = getFileName(opName);
        try (FileOutputStream fos = new FileOutputStream(fileName)) {
            fos.write(bytes);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }
    public String writeRandomAccessFile(byte[] bytes) {
        long tStart = System.currentTimeMillis();
        String opName = "writeRandomAccessFile";
        String fileName = getFileName(opName);
        try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
            raf.write(bytes);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }
    public String writeMappedByteBuffer(byte[] bytes) {
        long tStart = System.currentTimeMillis();
        String opName = "writeMappedByteBuffer";
        String fileName = getFileName(opName);
        try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
            FileChannel channel = raf.getChannel();
            MappedByteBuffer mbb = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);
            mbb.put(bytes);

        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }
    public String writeMappedByteBufferParallel(byte[] bytes) {
        long tStart = System.currentTimeMillis();
        String opName = "writeMappedByteBufferParallel";
        String fileName = getFileName(opName);
        ExecutorService writerExecutor = Executors.newFixedThreadPool(N_THREADS);

        List<BatchIndex> batches = getBatchesByNumThreads();
        List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> CompletableFuture.runAsync(() -> {
                    try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
                        try {
                            FileChannel channel = raf.getChannel();
                            MappedByteBuffer mbb = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);
                            int start = batch.getStart();
                            int length = batch.getEnd() - batch.getStart();

                            mbb.put(start, bytes, start, length);
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    } catch (IOException ex) {
                        System.out.println(ex.getMessage());
                    }
                }, writerExecutor))
                .toList();
        futures.forEach(CompletableFuture::join);
        writerExecutor.shutdown();
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }

    public String generateAndWriteMappedByteBuffer() { // not-fast
        long tStart = System.currentTimeMillis();
        String opName = "generateAndWriteMappedByteBuffer";
        String fileName = getFileName(opName);
        try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
            FileChannel channel = raf.getChannel();
            MappedByteBuffer mbb = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);
            byte[] bytes = generateBytesLib();
            mbb.put(bytes);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }
    public String generateAndWriteMappedByteBufferBatches() {
        long tStart = System.currentTimeMillis();
        String opName = "generateAndWriteMappedByteBufferBatches";
        String fileName = getFileName(opName);

        try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
            FileChannel channel = raf.getChannel();
            MappedByteBuffer mbb = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);
            byte[] bytes = new byte[BATCH_SIZE];

            int start = 0;
            while (true) {
                int end = Math.min(start + BATCH_SIZE, fileSize);
                int length = end - start;
                nextBytesLibBatch(bytes, 0, length);
                mbb.put(start, bytes, 0, length);
                if (end == fileSize)
                    break;
                start = end;
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }

    private void generateBatchBytesAndSentInfoToQueue(List<BatchIndex> batches, ArrayBlockingQueue<BatchIndex> queue, byte[] bytes) {
        for (BatchIndex batch : batches) {
            int length = batch.getEnd() - batch.getStart();
            nextBytesLibBatch(bytes, batch.getStart(), length);
            try {
                queue.put(batch);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private void writeBatchesToFileFromQueue(String fileName, List<BatchIndex> batches, ArrayBlockingQueue<BatchIndex> queue, byte[] bytes) {
        try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
            FileChannel channel = raf.getChannel();
            MappedByteBuffer mbb = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);
            for (int i = 0; i < batches.size(); i++) {
                BatchIndex batch = null;
                try {
                    batch = queue.take();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                if (batch == null) continue;
                int length = batch.getEnd() - batch.getStart();
                mbb.put(batch.getStart(), bytes, batch.getStart(), length);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }

    public String generateAndWriteMappedByteBufferBatchesQueue() {
        long tStart = System.currentTimeMillis();
        String opName = "generateAndWriteMappedByteBufferBatchesQueue";
        String fileName = getFileName(opName);

        byte[] bytes = new byte[fileSize];
        List<BatchIndex> chunks = getBatchesBySize();
        ArrayBlockingQueue<BatchIndex> queue = new ArrayBlockingQueue<>(chunks.size(), true);

        Thread generateThread = new Thread(() -> generateBatchBytesAndSentInfoToQueue(chunks, queue, bytes));
        generateThread.start();
        Thread writeThread = new Thread(() -> writeBatchesToFileFromQueue(fileName, chunks, queue, bytes));
        writeThread.start();
        try {
            generateThread.join();
            writeThread.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }
    public String generateAndWriteRandomAccessFileParallel() {
        long tStart = System.currentTimeMillis();
        String opName = "generateAndWriteRandomAccessFileParallel";
        String fileName = getFileName(opName);
        ExecutorService writerExecutor = Executors.newFixedThreadPool(N_THREADS);

        List<BatchIndex> batches = getBatchesByNumThreads();
        List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> CompletableFuture.runAsync(() -> {
                    try (RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
                        try {
                            int start = batch.getStart();
                            int length = batch.getEnd() - batch.getStart();
                            byte[] bytes = new byte[length];
                            random.nextBytes(bytes);
                            raf.seek(start);
                            raf.write(bytes, 0, length);
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    } catch (IOException ex) {
                        System.out.println(ex.getMessage());
                    }
                }, writerExecutor))
                .toList();
        futures.forEach(CompletableFuture::join);
        writerExecutor.shutdown();
        long tEnd = System.currentTimeMillis();
        logTime(opName, tStart, tEnd);
        return fileName;
    }

    // Reading
    public byte[] readBytesFromFile(String fileName) {
        byte[] bytes = new byte[fileSize];
        try (RandomAccessFile raf = new RandomAccessFile(fileName, "r")) {
            try {
                raf.read(bytes);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        return bytes;
    }

    // Utils
    public boolean checkRandomization(byte[] bytes) {
        int[] bytesCount = new int[256];
        for (byte aByte : bytes) {
            int index = (int)aByte + 128;
            bytesCount[index]++;
        }

        List<Integer> notGeneratedNumbers = new ArrayList<>();
        for (int i = 0; i < bytesCount.length; i++) {
            if (bytesCount[i] == 0)
                notGeneratedNumbers.add(i);
        }
        System.out.print("Check randomization: ");
        if (notGeneratedNumbers.isEmpty()) {
            System.out.println("All numbers were generated");
            return true;
        }
        else {
            System.out.println("Numbers, which were not generated:");
            notGeneratedNumbers.forEach(number -> System.out.print(number + " "));
            System.out.println();
            return false;
        }
    }
    private List<BatchIndex> getBatchesByNumThreads() {
        List<BatchIndex> result = new ArrayList<>();
        int start = 0;
        int batchSize = fileSize / N_THREADS;
        while (true) {
            int end = Math.min(start + batchSize, fileSize);
            result.add(new BatchIndex(start, end));
            if (end == fileSize)
                break;
            start = end;
        }
        return result;
    }
    private List<BatchIndex> getBatchesBySize() {
        List<BatchIndex> result = new ArrayList<>();
        int start = 0;
        int batchSize = BATCH_SIZE;
        while (true) {
            int end = Math.min(start + batchSize, fileSize);
            result.add(new BatchIndex(start, end));
            if (end == fileSize)
                break;
            start = end;
        }
        return result;
    }
    private byte generateByte() {
        int number = random.nextInt(256) - 128;
        return (byte)number;
    }
    private void nextBytesLibBatch(byte[] bytes, int offset, int length) {
        int len = offset + length;
        for (int i = offset; i < len; ) {
            for (int rnd = random.nextInt(),
                 n = Math.min(len - i, Integer.SIZE / Byte.SIZE);
                 n-- > 0; rnd >>= Byte.SIZE) {
                bytes[i++] = (byte) rnd;
            }
        }
    }
    private void nextBytesLib(byte[] bytes) {
        for (int i = 0, len = bytes.length; i < len; )
            for (int rnd = random.nextInt(),
                 n = Math.min(len - i, Integer.SIZE/Byte.SIZE);
                 n-- > 0; rnd >>= Byte.SIZE)
                bytes[i++] = (byte)rnd;
    }
    public void logTime(String operationName, long tStart, long tEnd) {
        System.out.println(String.format("Operation: %s - execution time = %d ms", operationName, tEnd - tStart));
    }

    private String getFileName(String operationName) {
        return catalog + operationName + "-" + getTimeSuffix() + ".txt";
    }
    private String getTimeSuffix() {
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH-mm-ss"));
    }
    private static class BatchIndex {
        private int start;
        private int end;

        public BatchIndex(int start, int end) {
            this.start = start;
            this.end = end;
        }

        public int getStart() {
            return start;
        }

        public int getEnd() {
            return end;
        }
    }

}
